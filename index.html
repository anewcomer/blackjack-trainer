<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blackjack Trainer</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            align-items: flex-start; 
            min-height: 100vh;
            background-color: #282c34;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px; 
        }

        .main-game-area {
            flex: 3; /* Takes up 3/4 of the space for game + history */
            display: flex;
            flex-direction: column;
            /* gap: 20px; Removed as history log is moving to a modal */
            max-width: 900px; /* Applied here for when strategy guide is side-by-side */
        }

        .game-container {
            background-color: #1a1e24;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            padding: 30px;
            text-align: center;
            width: 100%; /* Takes full width of its parent (.main-game-area) */
            box-sizing: border-box;
        }

        h1 {
            color: #61dafb;
            margin-bottom: 25px;
            font-size: 2.5em;
        }

        .game-area {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            gap: 20px;
        }

        .player-area, .dealer-area {
            background-color: #3a3f4a;
            border-radius: 10px;
            padding: 20px;
            flex: 1;
            min-height: 200px;
            position: relative;
        }

        h2 {
            color: #a8a8a8;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .cards {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            min-height: 80px; 
        }

        .card {
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 70px;
            height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .card.hidden {
            background-color: #888;
            color: #888;
            border: 1px solid #555;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="70" height="100" viewBox="0 0 70 100"><rect x="0" y="0" width="70" height="100" fill="%23888"/><line x1="0" y1="0" x2="70" y2="100" stroke="%23555" stroke-width="2"/><line x1="70" y1="0" x2="0" y2="100" stroke="%23555" stroke-width="2"/><circle cx="35" cy="50" r="15" fill="%23666"/></svg>');
            background-size: cover;
        }

        .card .rank {
            font-size: 1.5em;
            line-height: 1;
        }

        .card .suit {
            font-size: 1em;
            line-height: 1;
        }

        .card.red {
            color: red;
        }

        .score {
            font-size: 1.8em;
            font-weight: bold;
            color: #61dafb;
        }

        .actions {
            margin-top: 20px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }

        .action-button {
            background-color: #61dafb;
            color: #282c34;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .action-button:hover:not(:disabled) {
            background-color: #21a1f1;
            transform: translateY(-2px);
        }

        .action-button:disabled {
            background-color: #555;
            color: #aaa;
            cursor: not-allowed;
            box-shadow: none;
        }

        .new-game-button {
            background-color: #4CAF50;
        }

        .new-game-button:hover:not(:disabled) {
            background-color: #45a049;
        }

        .message {
            margin-top: 20px;
            font-size: 1.4em;
            font-weight: bold;
            min-height: 30px;
            color: #fdd835; 
        }

        .message.error {
            color: #ef5350; 
        }

        /* History Log Container */
        .modal-content #history-log-container { /* Styles for history log when inside a modal */
            background-color: transparent; /* Modal content will provide background */
            border-radius: 0; /* Modal content will have radius */
            box-shadow: none; /* Modal content will have shadow */
            padding: 0; /* Modal content will provide padding */
            color: #e0e0e0;
            font-size: 0.9em;
            text-align: left;
            width: auto;
            max-height: 65vh; /* Max height for the history log within the modal */
            overflow-y: auto; /* Scroll if content exceeds max-height */
        }

        #history-log-container h2 {
            text-align: center;
            color: #61dafb;
            margin-bottom: 15px;
        }

        #history-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }

        #history-table th, #history-table td {
            border: 1px solid #444;
            padding: 8px 6px;
            text-align: center;
            font-size: 0.85em;
        }

        #history-table th {
            background-color: #333;
            color: #61dafb;
            font-size: 0.9em;
        }

        #history-table tr:nth-child(even) {
            background-color: #222;
        }
        #history-table td.action-correct { color: #81C784; } /* Light Green */
        #history-table td.action-mistake { color: #FFB74D; } /* Light Orange */


        #session-stats {
            margin-top: 15px;
            padding: 15px;
            background-color: #282c34;
            border-radius: 8px;
            text-align: center;
        }
        #session-stats h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #61dafb;
        }
        #session-stats p {
            margin: 5px 0;
            font-size: 0.95em;
        }
        #session-stats .stat-value {
            font-weight: bold;
            color: #fff;
        }
        #session-stats .percentage {
            color: #aaa;
        }

        #new-session-button {
            display: block;
            margin: 20px auto 0 auto; /* Center the button */
            background-color: #E53E3E; /* Red */
        }
        #new-session-button:hover:not(:disabled) {
            background-color: #C53030; /* Darker Red */
        }

        #show-history-button {
            background-color: #03A9F4; /* Light Blue */
        }
        #show-history-button:hover:not(:disabled) {
            background-color: #0288D1; /* Darker Light Blue */
        }



        /* Basic Strategy Table Container */
        #strategy-guide-container {
            flex: 1; 
            background-color: #1a1e24; 
            border-radius: 15px;     
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5); 
            padding: 20px;           
            color: #e0e0e0;
            font-size: 0.9em;
            text-align: left;
            max-height: calc(100vh - 40px); 
            overflow-y: auto;
            overflow-x: hidden; 
        }

        .bs-table h3 { 
            margin-top: 0;
            margin-bottom: 10px;
            color: #61dafb;
            text-align: center;
        }
        
        #strategy-guide-container p { 
            text-align: center;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        /* Tab Styles */
        .tab-buttons {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 2px solid #444;
        }

        .tab-button {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            color: #a8a8a8;
            font-size: 1em;
            font-weight: bold;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px; 
            transition: color 0.3s ease, border-color 0.3s ease;
            flex-grow: 1; 
            text-align: center; 
        }

        .tab-button:hover {
            color: #61dafb;
        }

        .tab-button.active {
            color: #61dafb;
            border-bottom-color: #61dafb;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tab-content h4 {
            color: #a8a8a8;
            text-align: center;
            margin-top: 10px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        /* Styling for tables within the strategy guide */
        .bs-table table { /* Applied to strategy tables, reused for history table via id */
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .bs-table th, .bs-table td {
            border: 1px solid #444;
            padding: 6px 4px; 
            text-align: center;
            font-size: 0.85em; 
        }

        .bs-table th {
            background-color: #333;
            color: #61dafb;
            font-size: 0.9em; 
        }

        .bs-table tr:nth-child(even) {
            background-color: #222;
        }

        .bs-table .bs-action {
            font-weight: bold;
        }

        /* Color coding for strategy table cells */
        .bs-table td.bs-s { background-color: #5A677D; color: #e0e0e0; } 
        .bs-table td.bs-h { background-color: #D69E2E; color: #282c34; } 
        .bs-table td.bs-d { background-color: #38A169; color: #FFFFFF; } 
        .bs-table td.bs-p { background-color: #805AD5; color: #FFFFFF; } 
        .bs-table td.bs-r { background-color: #E53E3E; color: #FFFFFF; } 

        .bs-table td.bs-s,
        .bs-table td.bs-h,
        .bs-table td.bs-d,
        .bs-table td.bs-p,
        .bs-table td.bs-r {
            font-weight: bold;
        }

        .bs-table td.bs-highlight {
            outline: 3px solid yellow;
            outline-offset: -2px; /* Adjusts outline to be slightly inside the cell border */
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.7); /* Optional: adds a subtle glow */
        }

        @media (max-width: 1200px) { 
            body {
                flex-direction: column;
                align-items: center; 
            }

            .main-game-area, /* This will stack above strategy guide */
            #strategy-guide-container {
                flex: none; 
                width: 100%; 
                max-width: 900px; 
                margin-left: 0; 
                margin-bottom: 20px; 
            }
            
            /* #history-log-container max-height rule removed as it's now in a modal with vh unit */
            /* .modal-content #history-log-container {
                max-height: 300px; /* Adjust height for stacked view */

            #strategy-guide-container {
                max-height: 70vh; 
                padding: 15px; 
            }
            .bs-table th, .bs-table td,
            #history-table th, #history-table td {
                padding: 4px 2px;
                font-size: 0.8em;
            }
            .tab-button {
                font-size: 0.9em;
                padding: 8px 10px;
            }
        }
         @media (max-width: 768px) {
            .bs-table th, .bs-table td,
            #history-table th, #history-table td {
                font-size: 0.75em; 
                padding: 3px 1px;
            }
            #history-table td { /* Ensure actions column can wrap */
                word-break: break-word;
            }
            .tab-button {
                font-size: 0.8em;
            }
            .tab-content h4 {
                font-size: 1.1em;
            }
             #strategy-guide-container {
                font-size: 0.85em; 
            }
            #history-log-container {
                font-size: 0.8em;
            }
            #session-stats p {
                font-size: 0.9em;
            }
        }

        /* Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.7); /* Black w/ opacity */
            padding-top: 5vh; /* Location of the box */
        }

        .modal-content {
            background-color: #1a1e24; /* Match game-container */
            margin: auto;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.7);
            width: 85%;
            max-width: 900px; /* Max width for the modal content */
            position: relative;
        }

        .modal-close-button {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 30px;
            font-weight: bold;
            transition: color 0.3s ease;
        }

        .modal-close-button:hover,
        .modal-close-button:focus {
            color: #e0e0e0;
            text-decoration: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="main-game-area">
        <div class="game-container">
            <h1>Blackjack Trainer</h1>

            <div class="game-area">
                <div class="dealer-area">
                    <h2>Dealer's Hand</h2>
                    <div id="dealer-cards" class="cards"></div>
                    <div id="dealer-score" class="score"></div>
                </div>

                <div class="player-area">
                    <h2>Your Hand</h2>
                    <div id="player-cards" class="cards"></div>
                    <div id="player-score" class="score"></div>
                </div>
            </div>

            <div class="actions">
                <button id="hit-button" class="action-button">Hit</button>
                <button id="stand-button" class="action-button">Stand</button>
                <button id="double-button" class="action-button">Double Down</button>
                <button id="split-button" class="action-button">Split</button>
                <button id="surrender-button" class="action-button">Surrender</button>
                <button id="new-game-button" class="action-button new-game-button">New Game</button>
                <button id="show-history-button" class="action-button">Show History</button>
            </div>

            <div id="message" class="message">Click "New Game" to start.</div>
        </div>

    </div>

    <div id="strategy-guide-container" class="bs-table">
        <h3>Basic Strategy Reference (H17, DAS)</h3>
        <p>S: Stand, H: Hit, D: Double Down, P: Split, R: Surrender (R/H means Surrender if allowed, else Hit)</p>

        <div class="tab-buttons">
            <button class="tab-button active" data-tab="hard">Hard</button>
            <button class="tab-button" data-tab="soft">Soft</button>
            <button class="tab-button" data-tab="pairs">Pairs</button>
        </div>

        <div id="hard-tab" class="tab-content active">
            <h4>Hard Totals</h4>
            <table>
                <thead>
                    <tr>
                        <th>Hand</th>
                        <th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>A</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><b>17-21</b></td><td colspan="10" class="bs-action bs-s">S</td></tr>
                    <tr><td><b>16</b></td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-r">R/H</td><td class="bs-r">R/H</td><td class="bs-r">R/H</td></tr>
                    <tr><td><b>15</b></td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-r">R/H</td><td class="bs-r">R/H</td></tr>
                    <tr><td><b>14</b></td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>13</b></td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>12</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>11</b></td><td colspan="10" class="bs-action bs-d">D</td></tr>
                    <tr><td><b>10</b></td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>9</b></td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>5-8</b></td><td colspan="10" class="bs-action bs-h">H</td></tr>
                </tbody>
            </table>
        </div>

        <div id="soft-tab" class="tab-content">
            <h4>Soft Totals (Ace + Card)</h4>
            <table>
                <thead>
                    <tr>
                        <th>Hand</th>
                        <th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>A</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><b>A,9 (S20)</b></td><td colspan="10" class="bs-action bs-s">S</td></tr>
                    <tr><td><b>A,8 (S19)</b></td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-d">D/S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td></tr>
                    <tr><td><b>A,7 (S18)</b></td><td class="bs-d">D/S</td><td class="bs-d">D/S</td><td class="bs-d">D/S</td><td class="bs-d">D/S</td><td class="bs-d">D/S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>A,6 (S17)</b></td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>A,5 (S16)</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>A,4 (S15)</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>A,3 (S14)</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>A,2 (S13)</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                </tbody>
            </table>
        </div>

        <div id="pairs-tab" class="tab-content">
            <h4>Pairs</h4>
            <table>
                <thead>
                    <tr>
                        <th>Pair</th>
                        <th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>A</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><b>A,A</b></td><td colspan="10" class="bs-action bs-p">P</td></tr>
                    <tr><td><b>10,10</b></td><td colspan="10" class="bs-action bs-s">S</td></tr>
                    <tr><td><b>9,9</b></td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-s">S</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-s">S</td><td class="bs-s">S</td></tr>
                    <tr><td><b>8,8</b></td><td colspan="10" class="bs-action bs-p">P</td></tr>
                    <tr><td><b>7,7</b></td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>6,6</b></td><td class="bs-p">P/H</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>5,5</b></td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>4,4</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-p">P/H</td><td class="bs-p">P/H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>3,3</b></td><td class="bs-p">P/H</td><td class="bs-p">P/H</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>2,2</b></td><td class="bs-p">P/H</td><td class="bs-p">P/H</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- History Modal -->
    <div id="history-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close-button">&times;</span>
            <div id="history-log-container">
                <h2>Game History</h2>
                <table id="history-table">
                    <thead>
                        <tr>
                            <th>Player Initial</th>
                            <th>Dealer Upcard</th>
                            <th>Player Actions &amp; (Correctness)</th>
                            <th>Dealer Actions</th>
                            <th>Player Final</th>
                            <th>Dealer Final</th>
                            <th>Result</th>
                        </tr>
                    </thead>
                    <tbody id="history-table-body">
                        <!-- History rows will be appended here by JavaScript -->
                    </tbody>
                </table>
                <div id="session-stats">
                    <h3>Session Statistics</h3>
                    <p>Correct Decisions: <span id="correct-moves" class="stat-value">0</span> (<span id="correct-moves-percent" class="percentage">0%</span>)</p>
                    <p>Incorrect Decisions: <span id="incorrect-moves" class="stat-value">0</span> (<span id="incorrect-moves-percent" class="percentage">0%</span>)</p>
                    <p>Total Decisions: <span id="total-decisions" class="stat-value">0</span></p>
                    <hr style="border-color: #444; margin: 10px 0;">
                    <p>Wins: <span id="wins-count" class="stat-value">0</span> (<span id="wins-percent" class="percentage">0%</span>)</p>
                    <p>Losses: <span id="losses-count" class="stat-value">0</span> (<span id="losses-percent" class="percentage">0%</span>)</p>
                    <p>Pushes: <span id="pushes-count" class="stat-value">0</span> (<span id="pushes-percent" class="percentage">0%</span>)</p>
                    <p>Total Hands Played: <span id="total-hands-played" class="stat-value">0</span></p>
                </div>
                <button id="new-session-button" class="action-button new-game-button">New Session</button>
            </div>
        </div>
    </div>

    <script>
        // --- Game State Variables ---
        let deck = [];
        let playerHands = []; 
        let currentHandIndex = 0;
        let dealerHand = [];
        let currentRoundDealerActionsLog = []; // To store dealer's actions for the current round
        let gameActive = false;
        let canSurrender = false; 

        // --- History and Stats Variables ---
        let gameHistoryLog = [];
        let sessionStats = {
            correctMoves: 0,
            incorrectMoves: 0,
            totalDecisions: 0,
            wins: 0,
            losses: 0,
            pushes: 0,
            handsPlayed: 0
        };

        // --- DOM Elements ---
        const dealerCardsDiv = document.getElementById('dealer-cards');
        const dealerScoreDiv = document.getElementById('dealer-score');
        const playerCardsDiv = document.getElementById('player-cards');
        const playerScoreDiv = document.getElementById('player-score');
        const messageDiv = document.getElementById('message');

        const hitButton = document.getElementById('hit-button');
        const standButton = document.getElementById('stand-button');
        const doubleButton = document.getElementById('double-button');
        const splitButton = document.getElementById('split-button');
        const surrenderButton = document.getElementById('surrender-button');
        const newGameButton = document.getElementById('new-game-button');

        // Modal DOM Elements
        const historyModal = document.getElementById('history-modal');
        const showHistoryButton = document.getElementById('show-history-button');
        const closeHistoryModalButton = document.querySelector('#history-modal .modal-close-button');

        // History DOM Elements
        const historyTableBody = document.getElementById('history-table-body');
        const correctMovesSpan = document.getElementById('correct-moves');
        const correctMovesPercentSpan = document.getElementById('correct-moves-percent');
        const incorrectMovesSpan = document.getElementById('incorrect-moves');
        const incorrectMovesPercentSpan = document.getElementById('incorrect-moves-percent');
        const totalDecisionsSpan = document.getElementById('total-decisions');
        const winsCountSpan = document.getElementById('wins-count');
        const winsPercentSpan = document.getElementById('wins-percent');
        const lossesCountSpan = document.getElementById('losses-count');
        const lossesPercentSpan = document.getElementById('losses-percent');
        const pushesCountSpan = document.getElementById('pushes-count');
        const pushesPercentSpan = document.getElementById('pushes-percent');
        const totalHandsPlayedSpan = document.getElementById('total-hands-played');
        const newSessionButton = document.getElementById('new-session-button');


        // --- Card Data ---
        const suits = ['♠', '♥', '♦', '♣'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const values = {
            '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
            'J': 10, 'Q': 10, 'K': 10, 'A': 11
        };

        // --- Core Game Functions ---

        function createDeck() {
            deck = [];
            for (let i = 0; i < 6; i++) { 
                for (const suit of suits) {
                    for (const rank of ranks) {
                        deck.push({ rank, suit, value: values[rank] });
                    }
                }
            }
            shuffleDeck();
        }

        function shuffleDeck() {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function dealCard() {
            if (deck.length < 20) { 
                createDeck();
                messageDiv.textContent = "Shuffling a new shoe!";
            }
            return deck.pop();
        }

        function calculateHandValue(hand) {
            let value = 0;
            let numAces = 0;
            for (const card of hand) {
                value += card.value;
                if (card.rank === 'A') {
                    numAces++;
                }
            }
            while (value > 21 && numAces > 0) {
                value -= 10;
                numAces--;
            }
            return value;
        }

        function getHandScoreText(hand) {
            const value = calculateHandValue(hand);
            let text = `${value}`;
            const hasAce = hand.some(card => card.rank === 'A');
            if (hasAce) {
                let valueWithoutOneAce = 0;
                let acesFound = 0;
                for (const card of hand) {
                    if (card.rank === 'A' && acesFound === 0) {
                        valueWithoutOneAce += 1; 
                        acesFound++;
                    } else {
                        valueWithoutOneAce += card.value;
                    }
                }
                if (valueWithoutOneAce + 10 <= 21 && value === valueWithoutOneAce + 10) {
                     text += " (Soft)";
                }
            }
            return text;
        }


        function displayCards(hand, element, hideFirst = false) {
            element.innerHTML = '';
            hand.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('card');
                const shouldBeHidden = (index === 0 && hideFirst && gameActive && playerHands.length > 0 && currentHandIndex < playerHands.length && playerHands[currentHandIndex] && !playerHands[currentHandIndex].stood && !playerHands[currentHandIndex].busted);


                if (shouldBeHidden) {
                    cardDiv.classList.add('hidden');
                    cardDiv.innerHTML = ''; 
                } else {
                    cardDiv.innerHTML = `<div class="rank">${card.rank}</div><div class="suit">${card.suit}</div>`;
                    if (card.suit === '♥' || card.suit === '♦') {
                        cardDiv.classList.add('red');
                    }
                }
                element.appendChild(cardDiv);
            });
        }

        function updateDisplay() {
            if (playerHands.length > 0 && currentHandIndex < playerHands.length && playerHands[currentHandIndex]) {
                const currentHand = playerHands[currentHandIndex];
                displayCards(currentHand.cards, playerCardsDiv);
                playerScoreDiv.textContent = `Score: ${getHandScoreText(currentHand.cards)}`;
                if (playerHands.length > 1) {
                    playerScoreDiv.textContent += ` (Hand ${currentHandIndex + 1}/${playerHands.length})`;
                }
            } else {
                playerCardsDiv.innerHTML = '';
                playerScoreDiv.textContent = '';
            }

            const allPlayerHandsDone = playerHands.every(hand => hand.busted || hand.stood || hand.surrendered);
            const hideDealerFirstCard = gameActive && !allPlayerHandsDone;
            displayCards(dealerHand, dealerCardsDiv, hideDealerFirstCard);

            if (hideDealerFirstCard) {
                dealerScoreDiv.textContent = `Score: ?`;
            } else if (dealerHand.length > 0) {
                dealerScoreDiv.textContent = `Score: ${getHandScoreText(dealerHand)}`;
            } else {
                dealerScoreDiv.textContent = '';
            }
            
            const currentHand = (currentHandIndex < playerHands.length) ? playerHands[currentHandIndex] : null;
            const isPlayerTurn = gameActive && currentHand && !currentHand.busted && !currentHand.stood && !currentHand.surrendered;
            const hasInitialTwoCards = currentHand && currentHand.cards.length === 2 && !currentHand.splitFromPair;


            hitButton.disabled = !isPlayerTurn;
            standButton.disabled = !isPlayerTurn;
            doubleButton.disabled = !isPlayerTurn || !hasInitialTwoCards;
            // Allow split only if less than 4 hands already
            splitButton.disabled = !isPlayerTurn || !hasInitialTwoCards || !currentHand.cards[0] || !currentHand.cards[1] || currentHand.cards[0].rank !== currentHand.cards[1].rank || playerHands.length >= 4;
            surrenderButton.disabled = !isPlayerTurn || !canSurrender || (currentHand && currentHand.cards.length > 2);
        }

        function resetGame() { // Resets board for a new hand, not session
            gameActive = false;
            playerHands = [];
            currentRoundDealerActionsLog = [];
            dealerHand = [];
            currentHandIndex = 0;
            canSurrender = false;
            messageDiv.className = 'message';
            messageDiv.textContent = 'Click "New Game" to start.';
            playerCardsDiv.innerHTML = '';
            dealerCardsDiv.innerHTML = '';
            playerScoreDiv.textContent = '';
            dealerScoreDiv.textContent = '';
            newGameButton.disabled = false;
            disableActionButtons();
            updateDisplay(); 
        }

        function clearStrategyHighlights() {
            document.querySelectorAll('#strategy-guide-container td').forEach(td => {
                td.classList.remove('bs-highlight');
            });
        }


        async function newGame() {
            newGameButton.disabled = true; // Disable button at the very start

            resetGame(); 
            currentRoundDealerActionsLog = []; // Ensure it's reset for the new game
            createDeck(); 
            gameActive = true;
            canSurrender = true; 

            const newPlayerHand = { 
                cards: [], 
                busted: false, 
                stood: false, 
                doubled: false, 
                splitFromPair: false, 
                surrendered: false,
                initialCardsForThisHand: [], // For history log
                actionsTakenLog: []         // For history log
            };
            playerHands.push(newPlayerHand);
            dealerHand = [];

            playerHands[0].cards.push(dealCard());
            dealerHand.push(dealCard()); 
            playerHands[0].cards.push(dealCard());
            dealerHand.push(dealCard()); 

            playerHands[0].initialCardsForThisHand = [...playerHands[0].cards]; // Log initial state

            updateDisplay(); 

            const playerBlackjack = calculateHandValue(playerHands[0].cards) === 21;
            const dealerBlackjack = calculateHandValue(dealerHand) === 21;

            if (dealerBlackjack || playerBlackjack) {
                gameActive = false; 
                displayCards(dealerHand, dealerCardsDiv, false); 
                dealerScoreDiv.textContent = `Score: ${getHandScoreText(dealerHand)}`;
                // Log dealer's initial state for history if they have blackjack or game ends here
                if (dealerHand.length === 2) {
                    currentRoundDealerActionsLog.push({
                        action: dealerBlackjack ? 'Blackjack' : 'Reveal',
                        handValueBefore: calculateHandValue(dealerHand),
                        handValueAfter: calculateHandValue(dealerHand)
                    });
                }
                if (dealerBlackjack && playerBlackjack) {
                    messageDiv.textContent = "Push! Both have Blackjack.";
                    playerHands[0].stood = true; // Mark as resolved
                    resolveGame(); // Log this outcome
                } else if (dealerBlackjack) {
                    messageDiv.textContent = "Dealer has Blackjack! You lose.";
                    playerHands[0].stood = true; // Mark as resolved
                    resolveGame(); // Log this outcome
                } else { // Player Blackjack
                    messageDiv.textContent = "Blackjack! You win!";
                    playerHands[0].stood = true; // Mark as resolved
                    resolveGame(); // Log this outcome
                }
                // resolveGame() will re-enable the newGameButton, so no need to do it here.
                disableActionButtons();
                return;
            }

            messageDiv.textContent = "Your turn. What's your move?";
            // If we reach here, it means the game didn't auto-resolve. It's player's turn.
            // The newGameButton was enabled by resetGame(), but we disabled it at the start of newGame.
            // We should re-enable it now that the setup for the player's turn is complete.
            newGameButton.disabled = false; 
            updateDisplay(); 
        }

        function disableActionButtons() {
            hitButton.disabled = true;
            standButton.disabled = true;
            doubleButton.disabled = true;
            splitButton.disabled = true;
            splitButton.disabled = true;
            surrenderButton.disabled = true;
        }
        
        function recordAction(playerActionCode, handCardsForDecision, handValueBefore, handValueAfter) {
            if (!gameActive || currentHandIndex >= playerHands.length || !playerHands[currentHandIndex]) return;
            const currentHand = playerHands[currentHandIndex];
            // The dealer's upcard is the second card dealt to them, which is visible to the player.
            // dealerHand[0] is the hole card.
            const dealerUpCard = dealerHand.length > 1 ? dealerHand[1] : null; 
            if (!dealerUpCard) return; // Should not happen in normal play after deal
            
            const mistakeInfo = checkAndHighlightMistake(playerActionCode, handCardsForDecision, dealerUpCard);

            currentHand.actionsTakenLog.push({
                playerAction: playerActionCode,
                optimalAction: mistakeInfo.optimalMoveForLog,
                wasCorrect: !mistakeInfo.isMistake,
                handValueBefore: handValueBefore,
                handValueAfter: handValueAfter 
            });

            sessionStats.totalDecisions++;
            if (mistakeInfo.isMistake) {
                sessionStats.incorrectMoves++;
            } else {
                sessionStats.correctMoves++;
            }
            // renderSessionStats(); // Update stats display immediately or wait till resolveGame
        }


        async function playerHit() {
            if (!gameActive || currentHandIndex >= playerHands.length || !playerHands[currentHandIndex] || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) return;

            canSurrender = false; 
            const currentHand = playerHands[currentHandIndex];
            const handCardsBeforeHit = [...currentHand.cards]; // Capture cards before hit
            const handValueBefore = calculateHandValue(handCardsBeforeHit); // Calculate value from captured cards
            
            currentHand.cards.push(dealCard());
            const handValueAfter = calculateHandValue(currentHand.cards);
            recordAction('H', handCardsBeforeHit, handValueBefore, handValueAfter);
            updateDisplay(); 

            if (handValueAfter > 21) {
                currentHand.busted = true;
                messageDiv.textContent = `Hand ${currentHandIndex + 1} busted! Score: ${handValueAfter}`;
                // messageDiv.classList.add('error'); // checkAndHighlightMistake handles class
                await nextHandOrDealerTurn();
            } else if (handValueAfter === 21) {
                currentHand.stood = true; 
                await nextHandOrDealerTurn();
            }
        }

        async function playerStand() {
            if (!gameActive || currentHandIndex >= playerHands.length || !playerHands[currentHandIndex] || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) return;
            
            canSurrender = false;
            const currentHand = playerHands[currentHandIndex];
            const handValue = calculateHandValue(currentHand.cards);
            recordAction('S', currentHand.cards, handValue, handValue);
            currentHand.stood = true;
            updateDisplay();
            await nextHandOrDealerTurn(); 
        }

        async function playerDoubleDown() {
            if (!gameActive || currentHandIndex >= playerHands.length || !playerHands[currentHandIndex] || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) return;

            const currentHand = playerHands[currentHandIndex];
            if (currentHand.cards.length !== 2 || currentHand.splitFromPair) { 
                messageDiv.textContent = "Can only double down on your first two cards (not after split)!";
                messageDiv.classList.add('error');
                return;
            }
            canSurrender = false;
            
            const handCardsBeforeDouble = [...currentHand.cards]; // Capture cards before double
            const handValueBefore = calculateHandValue(handCardsBeforeDouble); // Calculate value from captured cards
            currentHand.doubled = true;
            currentHand.cards.push(dealCard());
            const handValueAfter = calculateHandValue(currentHand.cards);
            recordAction('D', handCardsBeforeDouble, handValueBefore, handValueAfter);
            updateDisplay();

            if (handValueAfter > 21) {
                currentHand.busted = true;
            }
            currentHand.stood = true; 
            await nextHandOrDealerTurn();
        }

        async function playerSplit() {
            if (!gameActive || currentHandIndex >= playerHands.length || !playerHands[currentHandIndex] || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) return;

            const currentHand = playerHands[currentHandIndex];
            if (currentHand.cards.length !== 2 || currentHand.cards[0].rank !== currentHand.cards[1].rank || playerHands.length >= 4) {
                messageDiv.textContent = "Cannot split this hand!";
                messageDiv.classList.add('error');
                return;
            }
            canSurrender = false;
            const handValueBeforeSplit = calculateHandValue(currentHand.cards);
            recordAction('P', currentHand.cards, handValueBeforeSplit, handValueBeforeSplit); // Record split decision

            const card1 = currentHand.cards[0];
            const card2 = currentHand.cards[1];

            // Create first new hand (replaces current)
            const hand1Cards = [card1, dealCard()];
            playerHands[currentHandIndex] = { 
                cards: hand1Cards, 
                busted: false, stood: false, doubled: false, 
                splitFromPair: true, surrendered: false,
                initialCardsForThisHand: [...hand1Cards], // Log initial state of this split hand
                actionsTakenLog: [] 
            };

            // Create second new hand (inserted after current)
            const hand2Cards = [card2, dealCard()];
            playerHands.splice(currentHandIndex + 1, 0, { 
                cards: hand2Cards, 
                busted: false, stood: false, doubled: false, 
                splitFromPair: true, surrendered: false,
                initialCardsForThisHand: [...hand2Cards], // Log initial state of this split hand
                actionsTakenLog: []
            });
            
            updateDisplay();

            // Handle Aces - only one card, then stand
            if (card1.rank === 'A') {
                playerHands[currentHandIndex].stood = true;
                if (playerHands[currentHandIndex+1]) playerHands[currentHandIndex+1].stood = true; 
            }
            
            if (playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) {
                 await nextHandOrDealerTurn(); 
            } else {
                updateDisplay(); 
                messageDiv.textContent = `Now playing Hand ${currentHandIndex + 1}. What's your move?`;
            }
        }

        async function playerSurrender() {
            if (!gameActive || !canSurrender || currentHandIndex >= playerHands.length || !playerHands[currentHandIndex] || playerHands[currentHandIndex].cards.length > 2) {
                 messageDiv.textContent = "Cannot surrender now.";
                 messageDiv.classList.add('error');
                 return;
            }
            
            const currentHand = playerHands[currentHandIndex];
            const handValue = calculateHandValue(currentHand.cards);
            recordAction('R', currentHand.cards, handValue, handValue); 
            currentHand.surrendered = true;
            currentHand.stood = true; 
            canSurrender = false;
            updateDisplay();
            await nextHandOrDealerTurn(); 
        }

        async function nextHandOrDealerTurn() {
            let nextHandFound = false;
            // Start searching from the current hand index IF it's resolved
            let searchStartIndex = currentHandIndex;
            if (playerHands[currentHandIndex] && (playerHands[currentHandIndex].busted || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].surrendered)) {
                searchStartIndex = currentHandIndex + 1; // Move to check next hand
            }
            
            for (let i = searchStartIndex; i < playerHands.length; i++) {
                if (!playerHands[i].busted && !playerHands[i].stood && !playerHands[i].surrendered) {
                    currentHandIndex = i;
                    nextHandFound = true;
                    break;
                }
            }
             // If no next hand found from searchStartIndex, but currentHandIndex itself is playable (e.g. after split, first new hand is active)
            if (!nextHandFound && playerHands[currentHandIndex] && !playerHands[currentHandIndex].busted && !playerHands[currentHandIndex].stood && !playerHands[currentHandIndex].surrendered) {
                nextHandFound = true; // Stay on current hand
            }


            if (nextHandFound) {
                updateDisplay();
                messageDiv.textContent = `Now playing Hand ${currentHandIndex + 1}. What's your move?`;
                const currentActiveHand = playerHands[currentHandIndex];
                canSurrender = currentActiveHand.cards.length === 2 && !currentActiveHand.splitFromPair; 
            } else {
                await dealerTurn();
            }
        }

        async function dealerTurn() {
            gameActive = false; 
            disableActionButtons(); 
            newGameButton.disabled = true; 

            const allPlayerHandsResolvedEarly = playerHands.every(hand => hand.busted || hand.surrendered);
            if (allPlayerHandsResolvedEarly && playerHands.length > 0) {
                // Log dealer's initial hand and effective "stand" if turn is skipped
                if (dealerHand.length > 0) { // Ensure dealer has cards
                    const initialDealerValue = calculateHandValue(dealerHand);
                    let alreadyRevealed = currentRoundDealerActionsLog.some(log => log.action === 'Reveal' || log.action === 'Blackjack');
                    if (!alreadyRevealed) {
                        currentRoundDealerActionsLog.push({
                            action: 'Reveal',
                            handValueBefore: initialDealerValue,
                            handValueAfter: initialDealerValue
                        });
                    }
                    // Add a "Stand" action because they didn't need to play
                    currentRoundDealerActionsLog.push({
                        action: 'S',
                        handValueBefore: initialDealerValue,
                        handValueAfter: initialDealerValue
                    });
                }
                messageDiv.textContent = "All player hands resolved. Dealer's turn skipped.";
                updateDisplay(); // Reveal dealer's hand
                await new Promise(resolve => setTimeout(resolve, 1000));
                resolveGame();
                return;
            }

            messageDiv.textContent = "Dealer's turn...";
            updateDisplay(); 
            await new Promise(resolve => setTimeout(resolve, 1000)); 

            let dealerValue = calculateHandValue(dealerHand);
            // Log initial state after revealing hole card, if not already logged (e.g. by early BJ check)
            if (!currentRoundDealerActionsLog.some(log => log.action === 'Reveal' || log.action === 'Blackjack')) {
                currentRoundDealerActionsLog.push({
                    action: 'Reveal',
                    handValueBefore: dealerValue,
                    handValueAfter: dealerValue
                });
            }

            while (dealerValue < 17 || (dealerValue === 17 && dealerHand.some(card => card.rank === 'A' && calculateHandValue(dealerHand.filter(c => c !== card)) + 11 === dealerValue))) {
                if (dealerValue >= 21) break; 
                messageDiv.textContent = `Dealer hits (score: ${getHandScoreText(dealerHand)}).`;
                await new Promise(resolve => setTimeout(resolve, 1500)); 
                
                const handValueBeforeHit = calculateHandValue(dealerHand);
                dealerHand.push(dealCard());
                dealerValue = calculateHandValue(dealerHand);
                const handValueAfterHit = dealerValue;
                currentRoundDealerActionsLog.push({
                    action: 'H',
                    handValueBefore: handValueBeforeHit,
                    handValueAfter: handValueAfterHit
                });
                updateDisplay();
            }
            await new Promise(resolve => setTimeout(resolve, 1000)); 
            if (dealerValue > 21) {
                messageDiv.textContent = `Dealer busts! (${dealerValue}).`;
            } else {
                messageDiv.textContent = `Dealer stands on ${getHandScoreText(dealerHand)}.`;
            }
            await new Promise(resolve => setTimeout(resolve, 1000)); 

            // Log final dealer action (Stand or Bust)
            const finalDealerValue = calculateHandValue(dealerHand); // Recalculate just in case
            if (dealerValue > 21) {
                currentRoundDealerActionsLog.push({ action: 'Bust', handValueBefore: finalDealerValue, handValueAfter: finalDealerValue });
            } else {
                // Avoid duplicate Stand if last action was already a Stand due to loop condition
                const lastDealerAction = currentRoundDealerActionsLog.length > 0 ? currentRoundDealerActionsLog[currentRoundDealerActionsLog.length -1].action : null;
                if (lastDealerAction !== 'S' && lastDealerAction !== 'Bust') { // Only add Stand if not already busted or stood
                    currentRoundDealerActionsLog.push({ action: 'S', handValueBefore: finalDealerValue, handValueAfter: finalDealerValue });
                }
            }


            resolveGame();
        }

        function resolveGame() {
            const dealerValue = calculateHandValue(dealerHand);
            const dealerBusted = dealerValue > 21;
            let finalMessageParts = ["<h3>Game Over</h3>"];

            playerHands.forEach((hand, index) => {
                sessionStats.handsPlayed++;
                const playerValue = calculateHandValue(hand.cards);
                let handResultText = `Hand ${index + 1} (${playerValue}): `;
                let resultOutcome;

                if (hand.surrendered) {
                    handResultText += "Surrendered. You lose.";
                    resultOutcome = "Loss";
                    sessionStats.losses++;
                } else if (hand.busted) {
                    handResultText += "Busted. You lose.";
                    resultOutcome = "Bust";
                    sessionStats.losses++;
                } else if (dealerBusted) {
                    handResultText += "Dealer busts. You win!";
                    resultOutcome = "Win";
                    sessionStats.wins++;
                } else if (playerValue > dealerValue) {
                    handResultText += `You win! (${playerValue} vs Dealer ${dealerValue})`;
                    resultOutcome = "Win";
                    sessionStats.wins++;
                } else if (playerValue < dealerValue) {
                    handResultText += `You lose. (${playerValue} vs Dealer ${dealerValue})`;
                    resultOutcome = "Loss";
                    sessionStats.losses++;
                } else { 
                    handResultText += `Push. (${playerValue} vs Dealer ${dealerValue})`;
                    resultOutcome = "Push";
                    sessionStats.pushes++;
                }
                finalMessageParts.push(`<p>${handResultText}</p>`);

                // Add to game history log
                const historyEntry = {
                    playerInitialDisplay: formatCardsForDisplay(hand.initialCardsForThisHand),
                    dealerUpCardDisplay: dealerHand.length > 0 ? formatCardForDisplay(dealerHand[0]) : "N/A",
                    actionsSummary: formatActionsLogForDisplay(hand.actionsTakenLog),
                    dealerActionsSummary: formatDealerActionsForDisplay(currentRoundDealerActionsLog),
                    playerFinalDisplay: `${playerValue}${hand.busted ? ' (Bust)' : ''}${hand.surrendered ? ' (Surrender)' : ''}`,
                    dealerFinalDisplay: `${dealerValue}${dealerBusted ? ' (Bust)' : ''}`,
                    result: resultOutcome,
                    isSplit: hand.splitFromPair
                };
                gameHistoryLog.push(historyEntry);
            });
            
            messageDiv.innerHTML = finalMessageParts.join('');
            messageDiv.className = 'message'; 

            renderHistoryTable();
            renderSessionStats();

            newGameButton.disabled = false; 
            disableActionButtons(); 
            updateDisplay(); 
            // clearStrategyHighlights(); // updateDisplay() should handle this now
        }

        // --- Basic Strategy Logic (H17, DAS) ---
        function getOptimalPlay(playerHandCards, dealerUpCard, canSplit, canDouble, canSurrenderNow) {
            const playerValue = calculateHandValue(playerHandCards);
            const dealerCardValue = dealerUpCard.value; 
            const dealerIsAce = dealerUpCard.rank === 'A';
            const dealerIsTen = dealerCardValue === 10;

            const isPlayerPair = playerHandCards.length === 2 && playerHandCards[0].rank === playerHandCards[1].rank;
            let isPlayerSoft = false;
            if (playerHandCards.some(c => c.rank === 'A')) {
                let nonAceTotal = 0;
                let aceCount = 0;
                playerHandCards.forEach(c => {
                    if (c.rank === 'A') aceCount++; else nonAceTotal += c.value;
                });
                if (aceCount > 0 && nonAceTotal + 11 + (aceCount - 1) === playerValue && playerValue <= 21) {
                    isPlayerSoft = true;
                }
            }
            
            if (canSurrenderNow && playerHandCards.length === 2 && !isPlayerPair) { 
                if (playerValue === 16 && (dealerUpCard.rank === '9' || dealerIsTen || dealerIsAce)) return 'R';
                if (playerValue === 15 && (dealerIsTen || dealerIsAce)) return 'R'; // Adjusted for H17 common surrender
            }

            if (isPlayerPair && canSplit) {
                const pRank = playerHandCards[0].rank;
                if (pRank === 'A') return 'P';
                if (pRank === '10' || pRank === 'J' || pRank === 'Q' || pRank === 'K') return 'S'; 
                if (pRank === '9') {
                    if (dealerCardValue === 7 || dealerIsTen || dealerIsAce) return 'S';
                    return 'P';
                }
                if (pRank === '8') return 'P'; 
                if (pRank === '7') return (dealerCardValue >= 2 && dealerCardValue <= 7) ? 'P' : 'H';
                if (pRank === '6') return (dealerCardValue >= 2 && dealerCardValue <= 6) ? 'P' : 'H'; 
                if (pRank === '5') return (canDouble && dealerCardValue >= 2 && dealerCardValue <= 9) ? 'D' : 'H'; 
                if (pRank === '4') { 
                    if (canDouble && (dealerCardValue === 5 || dealerCardValue === 6)) return 'P'; // P/H (Split if DAS, else Hit)
                    return 'H';
                }
                if (pRank === '3' || pRank === '2') {
                    if (dealerCardValue >= 2 && dealerCardValue <= 7) return 'P'; 
                    return 'H';
                }
            }

            if (isPlayerSoft) {
                if (playerValue >= 20) return 'S'; 
                if (playerValue === 19) { 
                     return (canDouble && dealerCardValue === 6) ? 'D' : 'S'; 
                }
                if (playerValue === 18) { 
                    if (canDouble && dealerCardValue >= 2 && dealerCardValue <= 6) return 'D'; 
                    if (dealerCardValue <= 8) return 'S';
                    return 'H';
                }
                if (playerValue === 17) { 
                    if (canDouble && dealerCardValue >= 3 && dealerCardValue <= 6) return 'D';
                    return 'H';
                }
                if (playerValue === 16 || playerValue === 15) { 
                    if (canDouble && dealerCardValue >= 4 && dealerCardValue <= 6) return 'D';
                    return 'H';
                }
                if (playerValue === 14 || playerValue === 13) { 
                    if (canDouble && dealerCardValue >= 5 && dealerCardValue <= 6) return 'D';
                    return 'H';
                }
            }

            // Hard Totals (also fallback for pairs/soft not meeting specific conditions)
            if (playerValue >= 17) return 'S';
            if (playerValue === 16) return (dealerCardValue >= 2 && dealerCardValue <= 6) ? 'S' : 'H';
            if (playerValue === 15) return (dealerCardValue >= 2 && dealerCardValue <= 6) ? 'S' : 'H';
            if (playerValue === 14) return (dealerCardValue >= 2 && dealerCardValue <= 6) ? 'S' : 'H';
            if (playerValue === 13) return (dealerCardValue >= 2 && dealerCardValue <= 6) ? 'S' : 'H';
            if (playerValue === 12) return (dealerCardValue >= 4 && dealerCardValue <= 6) ? 'S' : 'H';
            if (playerValue === 11) return canDouble ? 'D' : 'H';
            if (playerValue === 10) return (canDouble && dealerCardValue >= 2 && dealerCardValue <= 9) ? 'D' : 'H';
            if (playerValue === 9) return (canDouble && dealerCardValue >= 3 && dealerCardValue <= 6) ? 'D' : 'H';
            if (playerValue <= 8) return 'H';

            return 'H'; 
        }


        function checkAndHighlightMistake(playerAction, playerHandCards, dealerUpCard) {
            if (!gameActive || currentHandIndex >= playerHands.length || !playerHands[currentHandIndex] || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) {
                return { optimalMoveForLog: playerAction, isMistake: false }; // No check if not relevant
            }

            const currentHandObject = playerHands[currentHandIndex]; // Used for hand properties like .stood, .busted, .splitFromPair
            if (currentHandObject.stood || currentHandObject.busted) { // Already resolved (e.g. split aces)
                 return { optimalMoveForLog: playerAction, isMistake: false };
            }

            // For DAS strategy, doubling is allowed on any 2-card hand, even after a split.
            // These capabilities must be determined based on playerHandCards (the hand state at the moment of decision)
            const actualCanDouble = playerHandCards.length === 2;

            const actualCanSplit = actualCanDouble && // relies on playerHandCards.length
                                   playerHandCards[0] && playerHandCards[1] && // Ensure cards exist before accessing rank
                                   playerHandCards[0].rank === playerHandCards[1].rank &&
                                   playerHands.length < 4; // playerHands.length is about total number of split hands

            const actualCanSurrenderGlobal = canSurrender && // global game state flag
                                             playerHandCards.length === 2 &&
                                             !currentHandObject.splitFromPair; // .splitFromPair is a characteristic of the hand object

            // playerHandCards (the second argument to this function) is the state of the hand at decision time.
            const optimalSingleMove = getOptimalPlay(playerHandCards, dealerUpCard, actualCanSplit, actualCanDouble, actualCanSurrenderGlobal);
            const isMistake = (playerAction !== optimalSingleMove);
            const chosenActionText = mapActionCodeToText(playerAction);
            const optimalActionText = mapActionCodeToText(optimalSingleMove);

            if (isMistake) {
                messageDiv.textContent = `Mistake! You chose ${chosenActionText}. Optimal: ${optimalActionText}.`;
                messageDiv.classList.add('error');
            } else {
                messageDiv.textContent = `Correct! You chose ${chosenActionText}. (Optimal: ${optimalActionText})`;
                messageDiv.classList.remove('error');
                // messageDiv.classList.add('message'); // Already has 'message' or will be set by game flow
            }
            return { optimalMoveForLog: optimalSingleMove, isMistake: isMistake };
        }

        function mapActionCodeToText(code) {
            if (!code) return "Unknown";
            switch (code) {
                case 'H': return 'Hit';
                case 'S': return 'Stand';
                case 'D': return 'Double';
                case 'P': return 'Split';
                case 'R': return 'Surrender';
                default: return `Unknown (${code})`;
            }
        }

        function setActiveBsTab(tabIdToShow) {
            // Use existing tabButtons and tabContents which are globally scoped in the script
            document.querySelectorAll('#strategy-guide-container .tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('#strategy-guide-container .tab-content').forEach(content => content.classList.remove('active'));

            const buttonToShow = document.querySelector(`#strategy-guide-container .tab-button[data-tab="${tabIdToShow}"]`);
            const contentToShow = document.getElementById(tabIdToShow + '-tab');

            if (buttonToShow) buttonToShow.classList.add('active');
            if (contentToShow) contentToShow.classList.add('active');
        }

        function updateStrategyHighlight() {
            clearStrategyHighlights();

            if (!gameActive || currentHandIndex >= playerHands.length || !playerHands[currentHandIndex] ||
                playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted || playerHands[currentHandIndex].surrendered) {
                return; // Not player's active turn or hand resolved
            }

            const currentHand = playerHands[currentHandIndex];
            const playerHandCards = currentHand.cards;
            // The dealer's upcard is the second card dealt to them.
            // dealerHand[0] is the hole card.
            const dealerUpCard = dealerHand.length > 1 ? dealerHand[1] : null;


            if (!dealerUpCard || playerHandCards.length === 0) return;

            const playerValue = calculateHandValue(playerHandCards);
            let isPlayerSoft = false;
            const handValueForSoftCheck = playerValue; // Use the already calculated playerValue
            if (playerHandCards.some(c => c.rank === 'A')) {
                let valueIfAllAcesAreOne = 0;
                let numAcesInHand = 0;
                playerHandCards.forEach(card => {
                    if (card.rank === 'A') { valueIfAllAcesAreOne += 1; numAcesInHand++; } 
                    else { valueIfAllAcesAreOne += card.value; }
                });
                if (numAcesInHand > 0 && (valueIfAllAcesAreOne + 10) === handValueForSoftCheck && handValueForSoftCheck <= 21) {
                    isPlayerSoft = true;
                }
            }

            const isPlayerPair = playerHandCards.length === 2 && playerHandCards[0].rank === playerHandCards[1].rank;
            const canSplitCurrentHandForTab = isPlayerPair && playerHands.length < 4;

            let activeTabId = 'hard';
            let rowIndexQuery = '';
            let colIndex = -1;

            const dealerRank = dealerUpCard.rank;
            if (dealerRank === 'A') colIndex = 9;
            else if (['K', 'Q', 'J', '10'].includes(dealerRank)) colIndex = 8;
            else colIndex = parseInt(dealerRank) - 2;

            if (isPlayerPair && canSplitCurrentHandForTab) {
                activeTabId = 'pairs';
                const pRank = playerHandCards[0].rank;
                if (pRank === 'A') rowIndexQuery = 'A,A';
                else if (['K', 'Q', 'J', '10'].includes(pRank)) rowIndexQuery = '10,10';
                else rowIndexQuery = `${pRank},${pRank}`;
            } else if (isPlayerSoft) {
                activeTabId = 'soft';
                const otherCardValue = playerValue - 11; // Assumes one Ace is 11 for soft total
                if (playerValue >= 20) rowIndexQuery = 'A,9'; // S20 (A,9 or A,T etc.)
                else rowIndexQuery = `A,${otherCardValue}`; // e.g. A,7 for S18, A,2 for S13
            } else { // Hard totals
                activeTabId = 'hard';
                if (playerValue >= 17) rowIndexQuery = '17-21';
                else if (playerValue <= 8 && playerValue >= 5) rowIndexQuery = '5-8';
                else rowIndexQuery = playerValue.toString();
            }

            setActiveBsTab(activeTabId);
            const table = document.querySelector(`#${activeTabId}-tab table`);
            if (!table || colIndex < 0 || !rowIndexQuery) return;

            let targetRow = null;
            const rows = table.querySelectorAll('tbody tr'); // Ensure we are looking in tbody
            for (let row of rows) {
                const firstCellText = row.cells[0].textContent.trim();
                // For soft totals, table has "A,9 (S20)". Match "A,9".
                // For hard totals like "5-8", ensure exact match or appropriate range logic if needed (currently exact)
                if (activeTabId === 'soft' && firstCellText.startsWith(rowIndexQuery)) { // e.g. "A,7 (S18)" starts with "A,7"
                    targetRow = row; break; 
                } else if (firstCellText === rowIndexQuery) { // Exact match for "17-21", "16", "A,A", etc.
                    targetRow = row; break; 
                }
            }

            if (targetRow) {
                const actionCellIndex = colIndex + 1; // Player hand desc is cells[0], actions start from cells[1]
                if (targetRow.cells.length > actionCellIndex && targetRow.cells[actionCellIndex]) { // Standard row with individual cells for each dealer upcard
                    targetRow.cells[actionCellIndex].classList.add('bs-highlight');
                } else if (targetRow.cells.length === 2 && targetRow.cells[1] && targetRow.cells[1].hasAttribute('colspan')) {
                    // This handles rows like "17-21 S", "A,A P", "10,10 S", "8,8 P", "11 D" where one cell spans all dealer upcards
                    targetRow.cells[1].classList.add('bs-highlight');
                }
            }
        }

        // --- History Log and Stats Functions ---
        function formatCardForDisplay(card) {
            if (!card) return "N/A";
            return `${card.rank}${card.suit}`;
        }

        function formatCardsForDisplay(cardsArray) {
            if (!cardsArray || cardsArray.length === 0) return "N/A";
            return cardsArray.map(card => formatCardForDisplay(card)).join(', ');
        }

        function formatActionsLogForDisplay(actionsLogArray) {
            if (!actionsLogArray || actionsLogArray.length === 0) {
                return "N/A"; // Or specific message like "Auto-resolved"
            }
            let listItems = actionsLogArray.map(log => {
                let valChange = "";
                if (log.playerAction === 'H' || log.playerAction === 'D') {
                    valChange = ` (${log.handValueBefore}→${log.handValueAfter})`;
                } else if (log.playerAction) { // For S, P, R
                    valChange = ` (${log.handValueBefore})`;
                }
                const optimalActionText = log.optimalAction ? mapActionCodeToText(log.optimalAction) : "N/A";
                const correctness = log.wasCorrect ? `Correct: ${optimalActionText}` : `Mistake (Optimal: ${optimalActionText})`;
                return `<li>${mapActionCodeToText(log.playerAction)}${valChange}, ${correctness}</li>`;
            }).join('');
            return `<ol style="margin: 0; padding-left: 1.2em; text-align: left;">${listItems}</ol>`;
        }

        function formatDealerActionsForDisplay(dealerActionsLogArray) {
            if (!dealerActionsLogArray || dealerActionsLogArray.length === 0) return "N/A";
            let listItems = dealerActionsLogArray.map(log => {
                let valChange = "";
                let actionText = "";

                switch(log.action) {
                    case 'H': actionText = 'Hit'; valChange = ` (${log.handValueBefore}→${log.handValueAfter})`; break;
                    case 'S': actionText = 'Stand'; valChange = ` (${log.handValueBefore})`; break;
                    case 'Bust': actionText = 'Bust'; valChange = ` (${log.handValueBefore})`; break;
                    case 'Reveal': actionText = 'Reveals Hole Card'; valChange = ` (${log.handValueBefore})`; break;
                    case 'Blackjack': actionText = 'Blackjack!'; valChange = ` (${log.handValueBefore})`; break;
                    default: actionText = mapActionCodeToText(log.action); valChange = ` (${log.handValueBefore})`;
                }
                return `<li>${actionText}${valChange}</li>`;
            }).join('');
            // Using padding-left: 0 and list-style-position: inside for tighter packing if numbers are desired
            // Or padding-left: 1.2em for more space if numbers are outside.
            // Let's try list-style-position: inside; padding-left: 0;
            return `<ol style="margin: 0; padding-left: 0; list-style-position: inside; text-align: left;">${listItems}</ol>`;
        }

        function renderHistoryTable() {
            historyTableBody.innerHTML = ''; // Clear existing rows
            gameHistoryLog.slice().reverse().forEach(entry => { // Newest first
                const row = historyTableBody.insertRow();
                row.insertCell().textContent = entry.playerInitialDisplay;
                row.insertCell().textContent = entry.dealerUpCardDisplay;
                
                const actionsCell = row.insertCell();
                actionsCell.innerHTML = entry.actionsSummary.replace(/Correct:/g, '<span class="action-correct">Correct:</span>')
                                                          .replace(/Mistake/g, '<span class="action-mistake">Mistake</span>');
                
                const dealerActionsCell = row.insertCell();
                dealerActionsCell.innerHTML = entry.dealerActionsSummary;

                row.insertCell().textContent = entry.playerFinalDisplay;
                row.insertCell().textContent = entry.dealerFinalDisplay;
                row.insertCell().textContent = entry.result;
            });
        }

        function renderSessionStats() {
            correctMovesSpan.textContent = sessionStats.correctMoves;
            incorrectMovesSpan.textContent = sessionStats.incorrectMoves;
            totalDecisionsSpan.textContent = sessionStats.totalDecisions;

            correctMovesPercentSpan.textContent = sessionStats.totalDecisions > 0 ? ((sessionStats.correctMoves / sessionStats.totalDecisions) * 100).toFixed(1) + '%' : '0%';
            incorrectMovesPercentSpan.textContent = sessionStats.totalDecisions > 0 ? ((sessionStats.incorrectMoves / sessionStats.totalDecisions) * 100).toFixed(1) + '%' : '0%';

            winsCountSpan.textContent = sessionStats.wins;
            lossesCountSpan.textContent = sessionStats.losses;
            pushesCountSpan.textContent = sessionStats.pushes;
            totalHandsPlayedSpan.textContent = sessionStats.handsPlayed;

            winsPercentSpan.textContent = sessionStats.handsPlayed > 0 ? ((sessionStats.wins / sessionStats.handsPlayed) * 100).toFixed(1) + '%' : '0%';
            lossesPercentSpan.textContent = sessionStats.handsPlayed > 0 ? ((sessionStats.losses / sessionStats.handsPlayed) * 100).toFixed(1) + '%' : '0%';
            pushesPercentSpan.textContent = sessionStats.handsPlayed > 0 ? ((sessionStats.pushes / sessionStats.handsPlayed) * 100).toFixed(1) + '%' : '0%';
        }

        function startNewSession() {
            gameHistoryLog = [];
            sessionStats = {
                correctMoves: 0, incorrectMoves: 0, totalDecisions: 0,
                wins: 0, losses: 0, pushes: 0, handsPlayed: 0
            };
            renderHistoryTable();
            renderSessionStats();
            newGame(); // Start a fresh game on the board
            // updateDisplay will call updateStrategyHighlight if appropriate
        }


        // --- Tab Functionality for Strategy Guide ---
        const tabButtons = document.querySelectorAll('#strategy-guide-container .tab-button');
        const tabContents = document.querySelectorAll('#strategy-guide-container .tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));

                button.classList.add('active');
                const tabId = button.dataset.tab;
                const targetTabContent = document.getElementById(tabId + '-tab');
                if (targetTabContent) {
                    targetTabContent.classList.add('active');
                }
            });
        });

        // --- Event Listeners ---
        newGameButton.addEventListener('click', newGame);
        hitButton.addEventListener('click', playerHit);
        standButton.addEventListener('click', playerStand);
        doubleButton.addEventListener('click', playerDoubleDown);
        splitButton.addEventListener('click', playerSplit);
        surrenderButton.addEventListener('click', playerSurrender);
        newSessionButton.addEventListener('click', startNewSession);
        showHistoryButton.addEventListener('click', () => {
            historyModal.style.display = 'block';
            // Ensure the history log container within the modal scrolls to the top
            const historyLogContainer = document.getElementById('history-log-container');
            if (historyLogContainer) {
                historyLogContainer.scrollTop = 0;
            }
        });
        closeHistoryModalButton.addEventListener('click', () => {
            historyModal.style.display = 'none';
        });
        window.addEventListener('click', (event) => {
            if (event.target === historyModal) {
                historyModal.style.display = 'none';
            }
        });

        // Initial setup
        resetGame();
        // Call clearStrategyHighlights explicitly in resetGame or ensure updateDisplay does it.
        // updateDisplay is called in resetGame, which will handle clearing or setting highlights.
        renderSessionStats(); // Initialize stats display

        // Modify updateDisplay to call strategy highlighting
        const originalUpdateDisplay = updateDisplay;
        updateDisplay = function() {
            originalUpdateDisplay.apply(this, arguments); // Call original display logic
            const currentHandForDisplay = (currentHandIndex < playerHands.length) ? playerHands[currentHandIndex] : null;
            const isPlayerActiveTurn = gameActive && currentHandForDisplay && // Ensure there's a hand
                                       currentHandForDisplay.cards && currentHandForDisplay.cards.length > 0 && // Ensure hand has cards
                                       !currentHandForDisplay.busted &&
                                       !currentHandForDisplay.stood &&
                                       !currentHandForDisplay.surrendered;
            if (isPlayerActiveTurn) { updateStrategyHighlight(); }
            else { clearStrategyHighlights(); }
        }
    </script>
</body>
</html>
